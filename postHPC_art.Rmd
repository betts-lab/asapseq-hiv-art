---
title: "postHPC"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(tidyverse)
suppressMessages(library(ArchR))
suppressMessages(library(GenomicFeatures))
suppressMessages(library(rtracklayer))
library(patchwork)
library(pheatmap)
library(UpSetR)
library(Seurat)
library(glue)

source("common_scripts/graphs.R")
source("common_scripts/archrCleaning.R")
```

```{r}
addArchRThreads(threads = 2)
```

```{r}
projInVitro <- loadArchRProject(path = "ND497_B_qcfiltTSS4/", showLogo = FALSE)

projInVitro <- addHaystackData(proj = projInVitro,
  haystackParentDir = "data/hiv-haystack",
  haystackSamples = c("ND497_B" = "ND497_B_v3"))
```

```{r}
projChronic <- loadArchRProject(path = "C01_qcfiltTSS4/", showLogo = FALSE)

uniqChronicSamples <- unique(projChronic$Sample)
haystackSamplePairingChronic <- paste0(uniqChronicSamples, "_hxb2")
names(haystackSamplePairingChronic) <- uniqChronicSamples
  
projChronic <- addHaystackData(proj = projChronic,
  haystackParentDir = "data/hiv-haystack",
  haystackSamples = haystackSamplePairingChronic)

projChronic <- addUMAP(ArchRProj = projChronic,
  reducedDims = "Harmony",
  name = "UMAP2",
  nNeighbors = 40,
  minDist = 0.4)
```

```{r}
projART <- loadArchRProject(path = "A08A01_qcfiltTSS4/", showLogo = FALSE)

# add haystack data
uniqSamples <- unique(projART$Sample)
haystackSamplePairingART <- sapply(uniqSamples, function(i) {
  newSampleName <- ifelse(grepl("A01", i), paste0(i, "_v3WithEnv"), paste0(i, "_v3"))
  return(newSampleName)
})

projART <- addHaystackData(proj = projART,
  haystackParentDir = "data/hiv-haystack",
  haystackSamples = haystackSamplePairingART)
```


```{r}
# proj_clustFilt <- addImputeWeights(proj_clustFilt)
# 
# pImpute <- plotEmbedding(
#     ArchRProj = proj_clustFilt, 
#     colorBy = "GeneScoreMatrix", 
#     name = c("TBX21", "SELL", "CCR7", "IL7R", "IL2RA", "CD27", "CD28", "FAS", "CD19"), 
#     embedding = "UMAP",
#     imputeWeights = getImputeWeights(proj_clustFilt)
# )
# 
# pImputeGrid <- lapply(pImpute, function(x) {
#     gene <- str_extract(x$labels$title, "(\\S+)$")
#     
#     x +
#       guides(color = FALSE, fill = FALSE) + 
#       theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
#       labs(title = gene,
#         x = "UMAP Dim 1",
#         y = "UMAP Dim 2") +
#       theme(
#         axis.line = element_line(colour = "black"),
#         axis.text.x = element_blank(),
#         axis.ticks.x = element_blank(),
#         axis.text.y = element_blank(),
#         axis.ticks.y = element_blank(),
#         plot.title = element_text(size = 12),
#         panel.border = element_blank(),
#         panel.background = element_blank(),
#         plot.margin = unit(c(0,0,0,0), "cm"),
#         plot.title.position = "plot"
#       )
# })
# do.call(cowplot::plot_grid, c(list(ncol = 3), pImputeGrid))
```


```{r}
# load processed adt datasets
tsa_catalog <- readRDS("rds/tsa_catalog.rds")
load("rds/invitro_seuratMerged.RData")
load("rds/chronic_seuratMerged.RData")
load("rds/ART_seuratMerged.RData")
```


```{r}
# make final datasets that contains both modalities
inVitroIntersectCbc <- getIntersectBarcodes(adtInVitro, projInVitro)
chronicIntersectCbc <- getIntersectBarcodes(adtChronic, projChronic)
ARTIntersectCbc <- getIntersectBarcodes(adtART, projART)

projInvitro_matched <- projInVitro[inVitroIntersectCbc, ]
projInvitro_matched <- filterClusterByProp(projInvitro_matched, 0.5)
adtInVitro_matched <- subset(adtInVitro, cells = projInvitro_matched$cellNames)

projChronic_matched <- projChronic[chronicIntersectCbc, ]
projChronic_matched <- filterClusterByProp(projChronic_matched, 0.5)
adtChronic_matched <- subset(adtChronic, cells = projChronic_matched$cellNames)

projART_matched <- projART[ARTIntersectCbc, ]
projART_matched <- filterClusterByProp(projART_matched, 0.5)
adtART_matched <- subset(adtART, cells = projART_matched$cellNames)
```


```{r}
# print out initial unlabeled umaps
plotDualUmap(projInvitro_matched, fn = "outs/png/InVitro_unlabeledCluster_dualUmap.png")

plotDualUmap(projChronic_matched, fn = "outs/png/Chronic_unlabeledCluster_dualUmap.png", embedding = "UMAP2")
plotDualUmap(projChronic_matched, fn = "outs/png/Chronic_unlabeledCluster_dualUmap_individual.png",
  embedding = "UMAP2", cluster = "Sample")

plotDualUmap(projART_matched, fn = "outs/png/ART_unlabeledCluster_dualUmap.png")
plotDualUmap(projART_matched, fn = "outs/png/ART_unlabeledCluster_dualUmap_individual.png", cluster = "Sample")
```


```{r}
# select features that aren't similar to isotype...not sure if this will really be necessary
inVitroIsoSimilar <- returnSimilarToIsotype(tsa_catalog, isoComparisonsInvitro, 0.05, 4)
chronicIsoSimilar <- returnSimilarToIsotype(tsa_catalog, isoComparisonsChronic, 0.05, 4)
ARTIsoSimilar <- returnSimilarToIsotype(tsa_catalog, isoComparisonsART, 0.05, 4)

inVitroAdtToUse <- returnADTNonSimilar(adtInVitro_matched, tsa_catalog, inVitroIsoSimilar)
chronicAdtToUse <- returnADTNonSimilar(adtChronic_matched, tsa_catalog, chronicIsoSimilar)
ARTAdtToUse <- returnADTNonSimilar(adtART_matched, tsa_catalog, ARTIsoSimilar)
```


```{r}
adtInVitro_matched$atacClusters <- projInvitro_matched$Clusters
adtChronic_matched$atacClusters <- projChronic_matched$Clusters
adtART_matched$atacClusters <- projART_matched$Clusters

getBasePanelAndMarkers(seu = adtInVitro_matched, tsa_catalog = tsa_catalog,
  pngFn = "outs/png/InVitro_basepanel.png", tsvFn = "outs/tsv/InVitro_initClusterMarkers.tsv")

getBasePanelAndMarkers(seu = adtChronic_matched, tsa_catalog = tsa_catalog,
  pngFn = "outs/png/chronic_basepanel.png", tsvFn = "outs/tsv/chronic_initClusterMarkers.tsv")

getBasePanelAndMarkers(seu = adtART_matched, tsa_catalog = tsa_catalog,
  pngFn = "outs/png/art_basepanel.png", tsvFn = "outs/tsv/art_initClusterMarkers.tsv")
```


```{r}
projInvitro_matched <- assignManualAnnotation(archrProj = projInvitro_matched,
  annotFn = "manualClusterAnnotations/invitro.csv")

adtInVitro_matched$manualClusterAnnot <- projInvitro_matched$manualClusterAnnot

plotDualUmap(projInvitro_matched,
  fn = "outs/png/inVitro_labeledCluster_dualUmap.png",
  cluster = "manualClusterAnnot")

plotDiscreteBar(projInvitro_matched, "outs/png/inVitro_discreteProportion_matched.png",
  cluster = "manualClusterAnnot",
  graphType = "proportion")

plotDiscreteBar(projInvitro_matched, "outs/png/inVitro_discreteAbsolute_matched.png",
  cluster = "manualClusterAnnot",
  graphType = "absolute")
```

```{r}
seuMerge_matched$haystackOut <- proj_clustFilt_matched$haystackOut
Idents(seuMerge_matched) <- "haystackOut"
hivPosMarkers <- FindAllMarkers(seuMerge_matched,
  assay = "tsa",
  slot = "data",
  test.use = "DESeq2",
  features = adtToUse)

filteredHivPosMarkers <- hivPosMarkers %>%
  left_join(tsa_catalog %>% dplyr::select(DNA_ID, cleanName), by = c("gene" = "DNA_ID")) %>% 
  filter(p_val_adj < 0.05) %>%
  group_by(cluster) %>%
  filter(avg_log2FC > 0) %>% 
  mutate(piScore = avg_log2FC * -log10(p_val_adj)) %>%
  arrange(desc(piScore), .by_group = TRUE)

clean_VlnPlot <- function(gList, finalplotCol = 5, newTitle = c()) {
  g_grob <- lapply(seq_along(gList), function(i) {
    x <- gList[[i]]
    x <- x +
      theme(axis.title = element_blank(),
            legend.position = "none")
    
    if (length(newTitle) > 0) {
      x <- x +
        labs(title = newTitle[i]) +
        theme(plot.title = element_text(size = 10))
    }
    
    x <- ggplot_build(x)
    x$data[[2]]$colour <- "#00000020"
    x$data[[2]]$size <- 0.2
    
    return(ggplot_gtable(x))
  })
  
  return(gridExtra::grid.arrange(grobs = g_grob, ncol = finalplotCol))
}

clean_VlnPlot(VlnPlot(seuMerge_matched, features = filteredHivPosMarkers$gene, combine = FALSE),
  newTitle = filteredHivPosMarkers$cleanName,
  finalplotCol = 4)

pSapPi <- filteredHivPosMarkers %>%
  mutate(cleanName = factor(cleanName, levels = rev(cleanName)),
    Status = ifelse(cluster == "FALSE", "HIV-", "HIV+")) %>%
  {ggplot(., aes(x = piScore, y = cleanName, color = Status)) +
    geom_point(size = 3) + 
    geom_segment(aes(x = 0, xend = piScore, y = cleanName, yend = cleanName), linetype = "dotted") +
    labs(y = "Surface marker",
      x = "Ï€ score (log2FC * -log10(adj pval))") +
    scale_x_continuous(expand = c(0, 0), limits = c(0, max(.$piScore + 0.3))) +
    theme_classic() +
    theme(axis.text.y = element_text(size = 6.5),
      legend.position = "none",
      strip.placement = "outside") +
    scale_color_manual(values = c("#999999", "#e63946")) +
    facet_grid(Status ~ ., scales = "free", space = "free")} 

ggsave("png/hiv_pos_enriched_markers_piScore.png", pSapPi, width = 3, height = 2, dpi = "retina")

rm(pSapPi)
```

```{r}
# save archr project
projCleaned <- saveArchRProject(ArchRProj = proj_clustFilt_matched,
  outputDirectory = "projCleaned_final",
  load = TRUE,
  threads = 2)
```

```{r}
# add peaks!
# run outside of rmd chunk
proj_clustFilt_matched <- addGroupCoverages(ArchRProj = proj_clustFilt_matched,
  groupBy = "haystackOut",
  minCells = 150, # adjustment needed
  minReplicates = 5,
  force = TRUE)

# projCleaned <- addGroupCoverages(ArchRProj = projCleaned,
#   groupBy = "annotClusters",
#   force = TRUE)

# run outside of rmd chunk
proj_clustFilt_matched <- addReproduciblePeakSet(
  ArchRProj = proj_clustFilt_matched, 
  groupBy = "haystackOut", 
  pathToMacs2 = "/Users/vince/anaconda3/envs/asapseq/bin/macs2",
  force = TRUE
)

# run outside of rmd chunk
proj_clustFilt_matched <- addPeakMatrix(proj_clustFilt_matched, force = TRUE)

# run outside of rmd chunk
markersPeaks <- getMarkerFeatures(
  ArchRProj = proj_clustFilt_matched, 
  useMatrix = "PeakMatrix", 
  groupBy = "haystackOut",
  bias = c("TSSEnrichment", "log10(nFrags)"),
  testMethod = "wilcoxon",
  useGroups = "TRUE",
  bgdGroups = "FALSE"
)

plotMarkers(seMarker = markersPeaks, name = "TRUE", cutOff = "FDR <= 0.1 & abs(Log2FC) >= 0.5", plotAs = "Volcano")

# takes forever to run...
# proj_clustFilt_matched <- addDeviationsMatrix(
#   ArchRProj = proj_clustFilt_matched, 
#   peakAnnotation = "Motif",
#   force = TRUE
# )
```
